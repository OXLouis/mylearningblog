# js笔记
## 数组
### 重点摘抄
* 本质上，数组属于一种特殊的对象。`typeof`运算符会返回数组的类型是`object`。--59
* 数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2...）。--67
* 数组的数字键不需要连续，`length`属性的值总是比最大的那个整数键大`1`。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。--136
* `length`属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到`length`设置的值。通过清空length可以做到clear的效果--137
* 值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响`length`属性的值。--186
* 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。--203
* 当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。--315
* 数组的空位是可以读取的，返回`undefined`。但注意某个位置是undefined不意味着这个位置是空位。undefined是空位的必要不充分条件。--338
* 使用`delete`命令删除一个数组成员，会形成空位，并且不会影响`length`属性。--346
* 如果一个对象的所有键名都是非负整数，并且有`length`属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。--406
* “类似数组的对象”的根本特征，就是具有`length`属性。--426
* 典型的“类似数组的对象”是函数的`arguments`对象，以及大多数 DOM 元素集，还有字符串。--438
* 数组的`slice`方法可以将“类似数组的对象”变成真正的数组。--462
* 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过`call()`把数组的方法放到对象上面。--468
### 我的笔记
* js的数组像python的list，而且更加灵活之处在于，它可以直接对任意下标赋值。--31
### 我的总结
## 基本语法
### 重点摘抄
### 我的笔记
### 我的总结
## 基本语法笔记--727
1. 变量提升可以不需要先声明再定义。
2. 有==和===两种判断，目前猜测前者会进行隐式类型转换而后者不会。
3. break 和 continue 可以加上标签跳出多重循环。
4. swtich因为变量像python一样不用预设类型，比原来功能更加强大了。
5. {}内的变量在外面仍然有效。
## 数据类型转换
### 重点摘抄
* JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。--9
* 强制转换主要指使用`Number`、`String`和`Boolean`三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。--29
* 使用`Number`函数，可以将任意类型的值转化成数值。--33
* `String`方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。--191
### 我的笔记
### 我的总结
## 错误处理机制
### 重点摘抄
### 我的笔记
### 我的总结
## 函数
### 重点摘抄
* 函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。--8
* `function`命令声明的代码区块，就是一个函数。`function`命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。--19
* 除了用`function`命令声明函数，还可以采用变量赋值的写法。--32
* 采用函数表达式声明函数时，`function`命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。--42
* 需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。--61
* 第三种声明函数的方式是`Function`构造函数。--68
* 你可以传递任意数量的参数给`Function`构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。--85
* 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。--107
* JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。--158
* JavaScript 引擎将函数名视同变量名，所以采用`function`命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。--182
* 需要注意的是通过赋值语句声明的函数，提升时只会提升变量名。会报错。
* 根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是`if`和`try`语句。--227
* 函数的`name`属性返回函数的名字。--267
* `name`属性的一个用处，就是获取参数函数的名字。--290
* 函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数。--306
* 函数的`toString`方法返回一个字符串，内容是函数的源码。函数内部的注释也可以返回。--319
* 作用域（scope）指的是变量存在的范围。在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。--373
* 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。--391
* 与全局作用域一样，函数作用域内部也会产生“变量提升”现象。`var`命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。--432
* 函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。--452
* 函数参数不是必需的，Javascript 允许省略参数。--527
* 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入`undefined`。--543
* 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。--558
* 如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。--573
* 如果有同名的参数，则取最后出现的那个值。--605
* `arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。--641
* 严格模式下，`arguments`对象是一个只读对象，修改它是无效的，但不会报错。--670
* 通过`arguments`对象的`length`属性，可以判断函数调用时到底带几个参数。--685
* 需要注意的是，虽然`arguments`很像数组，但它是一个对象。数组专有的方法（比如`slice`和`forEach`），不能在`arguments`对象上直接使用。--698
* 如果要让`arguments`对象使用数组方法，真正的解决方法是将`arguments`转为真正的数组。
* `arguments`对象带有一个`callee`属性，返回它所对应的原函数。--718
* 如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。--762
* 由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如`f2`记住了它诞生的环境`f1`，所以从`f2`可以得到`f1`的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。--792
* 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。--794
* 外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。--840
* 在 Javascript 中，圆括号`()`是一种运算符，跟在函数名之后，表示调用该函数。比如，`print()`就表示调用`print`函数。--844
* JavaScript 引擎规定，如果`function`关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是`function`关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。--863
* 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。--902
* `eval`命令的作用是，将字符串当作语句执行。--922
* 放在`eval`中的字符串，应该有独自存在的意义，不能用来与`eval`以外的命令配合使用。--931
* `eval`没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。--937
* JavaScript 引擎内部，`eval`实际上是一个引用，默认调用一个内部方法。这使得`eval`的使用分成两种情况，一种是像上面这样的调用`eval(expression)`，这叫做“直接使用”，这种情况下`eval`的作用域就是当前作用域。除此之外的调用方法，都叫“间接调用”，此时`eval`的作用域总是全局作用域。--977
* 与`eval`作用类似的还有`Function`构造函数。利用它生成一个函数，然后调用该函数，也能将字符串当作命令执行。--1004
### 我的笔记
### 我的总结
## 数值
### 重点摘抄
### 我的笔记
### 我的总结
## 数值章节笔记--663
1. js中所有数字都以浮点数类型存储，所以存在精度上限，大概在15位数左右。1 === 1.0 返回true
2. 以0开头的数，优先被解读为八进制，可以写二进制，八进制和十六进制的数。
3. 存在+0和-0，唯一的区别是除零运算结果是正无穷还是负无穷
4. 无穷的运算符合数学定义，很多无穷间运算的结果将产生NaN。
5. parseInt函数可以将字符串初步处理后转成int，第二个参数是转换成的进制，所以可以用来进行进制转换,最高是36进制，因为最多就只有36个符号，此时建立一种字符串到int的映射，有点像康拓展开。
6. parseFloat函数同理，可以识别科学计数法
7. NaN不等于自身。NaN == NaN //false
## 对象
### 重点摘抄
* 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。`如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用`。--82
* 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。--133
* 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。--259
* JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。--287
* 查看一个对象本身的所有属性，可以使用`Object.keys`方法。--304
* `delete`命令用于删除对象的属性，删除成功后返回`true`。--319
* 注意，删除一个不存在的属性，`delete`不报错，而且返回`true`。删除引用的属性会返回true，但是属性仍然可以访问。--334
* 另外，需要注意的是，`delete`命令只能删除对象本身的属性，无法删除继承的属性--361
* `in`运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。--374
* `for...in`循环用来遍历一个对象的全部属性。--393
* `for...in`循环有两个使用注意点。--424
* - 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
* - 它不仅遍历对象自身的属性，还遍历继承的属性。
* 如果继承的属性是可遍历的，那么就会被`for...in`循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用`for...in`的时候，应该结合使用`hasOwnProperty`方法，在循环内部判断一下，某个属性是否为对象自身的属性。--446
* with的作用是操作同一个对象的多个属性时，提供一些书写的方便。--472
* 在with语句块中调用对象的属性时可以不写对象名，直接写属性名。
* 但是如果对非对象属性赋值则会创建全局变量。
### 我的笔记
* 变量名更像是引用，对象创建之后，只要有引用就会一直存在。--137
* 给变量名重新赋值时，更像是创建了一个新的对象，并改变变量名的引用，将引用的对象直接进行更改。
### 我的总结
## 运算符
### 重点摘抄
* JavaScript 允许非数值的相加。--21
* 加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。--43
* 一般来说，对象的`valueOf`方法总是返回对象自身，这时再自动调用对象的`toString`方法，将其转为字符串。--82
* 知道了这个规则以后，就可以自己定义`valueOf`方法或`toString`方法，得到想要的结果。--92
* 指数运算符（`**`）完成指数运算，前一个运算子是底数，后一个运算子是指数。--244
* JavaScript 提供两种相等运算符：`==`和`===`。--431
* 简单说，它们的区别是相等运算符（`==`）比较两个值是否相等，严格相等运算符（`===`）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（`===`）直接返回`false`，而相等运算符（`==`）会将它们转换成同一个类型，再用严格相等运算符进行比较。
* 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回`true`，值不同就返回`false`。--450
* 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。--467
* 不管什么类型的值，经过取反运算后，都变成了布尔值。--669
* 两次取反就是将一个值转为布尔值的简便写法--679
* 且运算符可以多个连用，这时返回第一个布尔值为`false`的表达式的值--715
*  与或运算符不返回逻辑值，返回第一个跳出判断的表达式的值。--724
* js中位运算大小不超过unsigned int 范围。--857
* 使用二进制否运算取整，是所有取整方法中最快的一种。--902
* `void`运算符的作用是执行一个表达式，然后不返回任何值，或者说返回`undefined`。--1145
* 圆括号不是运算符，而是一种语法结构。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。--1253
### 我的笔记
### 我的总结
## 字符串
### 重点摘抄
### 我的笔记
### 我的总结
## 字符串笔记--293
1. js编译器竟然会将注释读入，利用多行注释可以输出字符串。
2. 字符串似乎自带c++的const属性，不能改变。
3. 反斜杠后接八进制、十六进制可以直接转义为对应Unicode码的字符
4. btoa(),atob()两个函数实现ascii 和 base64的互相转换。base64的目的是为了显示所有ascii码中出现的符号。 
5. encodeURIComponent和decodeURIComponent实现了将编码
## JavaScript 编程风格
### 重点摘抄
### 我的笔记
### 我的总结
## 数据类型
### 重点摘抄
### 我的笔记
### 我的总结
## 类型笔记--251
1. typeof 函数返回对象的类型，typeof null 返回 object
2. 在C里面false = 0 ，在js里面出现了更多这样的判断等价，null=false=undefined=''=0，好处是代码写起来更简单了。
